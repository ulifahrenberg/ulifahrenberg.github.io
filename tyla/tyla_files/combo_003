YUI.add('moodle-core-notification', function (Y, NAME) {

/**
 * The notification module provides a standard set of dialogues for use
 * within Moodle.
 *
 * @module moodle-core-notification
 * @main
 */

/**
 * To avoid bringing moodle-core-notification into modules in it's
 * entirety, we now recommend using on of the subclasses of
 * moodle-core-notification. These include:
 * <dl>
 *  <dt> moodle-core-notification-dialogue</dt>
 *  <dt> moodle-core-notification-alert</dt>
 *  <dt> moodle-core-notification-confirm</dt>
 *  <dt> moodle-core-notification-exception</dt>
 *  <dt> moodle-core-notification-ajaxexception</dt>
 * </dl>
 *
 * @class M.core.notification
 * @deprecated
 */
Y.log("The moodle-core-notification parent module has been deprecated. " +
        "Please use one of its subclasses instead.", 'moodle-core-notification', 'warn');


}, '@VERSION@', {
    "requires": [
        "moodle-core-notification-dialogue",
        "moodle-core-notification-alert",
        "moodle-core-notification-confirm",
        "moodle-core-notification-exception",
        "moodle-core-notification-ajaxexception"
    ]
});
YUI.add('moodle-core-dragdrop', function (Y, NAME) {

/* eslint-disable no-empty-function */
/**
 * The core drag and drop module for Moodle which extends the YUI drag and
 * drop functionality with additional features.
 *
 * @module moodle-core-dragdrop
 */
var MOVEICON = {
    pix: "i/move_2d",
    largepix: "i/dragdrop",
    component: 'moodle',
    cssclass: 'moodle-core-dragdrop-draghandle'
};

/**
 * General DRAGDROP class, this should not be used directly,
 * it is supposed to be extended by your class
 *
 * @class M.core.dragdrop
 * @constructor
 * @extends Base
 */
var DRAGDROP = function() {
    DRAGDROP.superclass.constructor.apply(this, arguments);
};

Y.extend(DRAGDROP, Y.Base, {
    /**
     * Whether the item is being moved upwards compared with the last
     * location.
     *
     * @property goingup
     * @type Boolean
     * @default null
     */
    goingup: null,

    /**
     * Whether the item is being moved upwards compared with the start
     * point.
     *
     * @property absgoingup
     * @type Boolean
     * @default null
     */
    absgoingup: null,

    /**
     * The class for the object.
     *
     * @property samenodeclass
     * @type String
     * @default null
     */
    samenodeclass: null,

    /**
     * The class on the parent of the item being moved.
     *
     * @property parentnodeclass
     * @type String
     * @default
     */
    parentnodeclass: null,

    /**
     * The label to use with keyboard drag/drop to describe items of the same Node.
     *
     * @property samenodelabel
     * @type Object
     * @default null
     */
    samenodelabel: null,

    /**
     * The label to use with keyboard drag/drop to describe items of the parent Node.
     *
     * @property samenodelabel
     * @type Object
     * @default null
     */
    parentnodelabel: null,

    /**
     * The groups for this instance.
     *
     * @property groups
     * @type Array
     * @default []
     */
    groups: [],

    /**
     * The previous drop location.
     *
     * @property lastdroptarget
     * @type Node
     * @default null
     */
    lastdroptarget: null,

    /**
     * Should the direction of a keyboard drag and drop item be detected.
     *
     * @property detectkeyboarddirection
     * @type Boolean
     * @default false
     */
    detectkeyboarddirection: false,

    /**
     * Listeners.
     *
     * @property listeners
     * @type Array
     * @default null
     */
    listeners: null,

    /**
     * The initializer which sets up the move action.
     *
     * @method initializer
     * @protected
     */
    initializer: function() {
        this.listeners = [];

        // Listen for all drag:start events.
        this.listeners.push(Y.DD.DDM.on('drag:start', this.global_drag_start, this));

        // Listen for all drag:over events.
        this.listeners.push(Y.DD.DDM.on('drag:over', this.globalDragOver, this));

        // Listen for all drag:end events.
        this.listeners.push(Y.DD.DDM.on('drag:end', this.global_drag_end, this));

        // Listen for all drag:drag events.
        this.listeners.push(Y.DD.DDM.on('drag:drag', this.global_drag_drag, this));

        // Listen for all drop:over events.
        this.listeners.push(Y.DD.DDM.on('drop:over', this.global_drop_over, this));

        // Listen for all drop:hit events.
        this.listeners.push(Y.DD.DDM.on('drop:hit', this.global_drop_hit, this));

        // Listen for all drop:miss events.
        this.listeners.push(Y.DD.DDM.on('drag:dropmiss', this.global_drag_dropmiss, this));

        // Add keybaord listeners for accessible drag/drop
        this.listeners.push(Y.one(Y.config.doc.body).delegate('key', this.global_keydown,
                'down:32, enter, esc', '.' + MOVEICON.cssclass, this));

        // Make the accessible drag/drop respond to a single click.
        this.listeners.push(Y.one(Y.config.doc.body).delegate('click', this.global_keydown,
                '.' + MOVEICON.cssclass, this));
    },

    /**
     * The destructor to shut down the instance of the dragdrop system.
     *
     * @method destructor
     * @protected
     */
    destructor: function() {
        new Y.EventHandle(this.listeners).detach();
    },

    /**
     * Build a new drag handle Node.
     *
     * @method get_drag_handle
     * @param {String} title The title on the drag handle
     * @param {String} classname The name of the class to add to the node
     * wrapping the drag icon
     * @param {String} iconclass Additional class to add to the icon.
     * @return Node The built drag handle.
     */
    get_drag_handle: function(title, classname, iconclass) {

        var dragelement = Y.Node.create('<span></span>')
            .addClass(classname)
            .setAttribute('title', title)
            .setAttribute('tabIndex', 0)
            .setAttribute('data-draggroups', this.groups)
            .setAttribute('role', 'button');
        dragelement.addClass(MOVEICON.cssclass);

        window.require(['core/templates'], function(Templates) {
            Templates.renderPix('i/move_2d', 'core').then(function(html) {
                var dragicon = Y.Node.create(html);
                dragicon.setStyle('cursor', 'move');
                if (typeof iconclass != 'undefined') {
                    dragicon.addClass(iconclass);
                }
                dragelement.appendChild(dragicon);
            });
        });

        return dragelement;
    },

    lock_drag_handle: function(drag, classname) {
        drag.removeHandle('.' + classname);
    },

    unlock_drag_handle: function(drag, classname) {
        drag.addHandle('.' + classname);
        drag.get('activeHandle').focus();
    },

    ajax_failure: function(response) {
        var e = {
            name: response.status + ' ' + response.statusText,
            message: response.responseText
        };
        return new M.core.exception(e);
    },

    in_group: function(target) {
        var ret = false;
        Y.each(this.groups, function(v) {
            if (target._groups[v]) {
                ret = true;
            }
        }, this);
        return ret;
    },
    /*
     * Drag-dropping related functions
     */
    global_drag_start: function(e) {
        // Get our drag object
        var drag = e.target;
        // Check that drag object belongs to correct group
        if (!this.in_group(drag)) {
            return;
        }
        // Store the nodes current style, so we can restore it later.
        this.originalstyle = drag.get('node').getAttribute('style');
        // Set some general styles here
        drag.get('node').setStyle('opacity', '.25');
        drag.get('dragNode').setStyles({
            opacity: '.75',
            borderColor: drag.get('node').getStyle('borderColor'),
            backgroundColor: drag.get('node').getStyle('backgroundColor')
        });
        drag.get('dragNode').empty();
        this.drag_start(e);
    },

    /**
     * Drag-dropping related functions
     *
     * @param {EventFacade} e
     */
    globalDragOver: function(e) {
        this.dragOver(e);
    },

    global_drag_end: function(e) {
        var drag = e.target;
        // Check that drag object belongs to correct group
        if (!this.in_group(drag)) {
            return;
        }
        // Put our general styles back
        drag.get('node').setAttribute('style', this.originalstyle);
        this.drag_end(e);
    },

    global_drag_drag: function(e) {
        var drag = e.target,
            info = e.info;

        // Check that drag object belongs to correct group
        if (!this.in_group(drag)) {
            return;
        }

        // Note, we test both < and > situations here. We don't want to
        // effect a change in direction if the user is only moving side
        // to side with no Y position change.

        // Detect changes in the position relative to the start point.
        if (info.start[1] < info.xy[1]) {
            // We are going up if our final position is higher than our start position.
            this.absgoingup = true;

        } else if (info.start[1] > info.xy[1]) {
            // Otherwise we're going down.
            this.absgoingup = false;
        }

        // Detect changes in the position relative to the last movement.
        if (info.delta[1] < 0) {
            // We are going up if our final position is higher than our start position.
            this.goingup = true;

        } else if (info.delta[1] > 0) {
            // Otherwise we're going down.
            this.goingup = false;
        }

        this.drag_drag(e);
    },

    global_drop_over: function(e) {
        // Check that drop object belong to correct group.
        if (!e.drop || !e.drop.inGroup(this.groups)) {
            return;
        }

        // Get a reference to our drag and drop nodes.
        var drag = e.drag.get('node'),
            drop = e.drop.get('node');

        // Save last drop target for the case of missed target processing.
        this.lastdroptarget = e.drop;

        // Are we dropping within the same parent node?
        if (drop.hasClass(this.samenodeclass)) {
            var where;

            if (this.goingup) {
                where = "before";
            } else {
                where = "after";
            }

            // Add the node contents so that it's moved, otherwise only the drag handle is moved.
            drop.insert(drag, where);
        } else if ((drop.hasClass(this.parentnodeclass) || drop.test('[data-droptarget="1"]')) && !drop.contains(drag)) {
            // We are dropping on parent node and it is empty
            if (this.goingup) {
                drop.append(drag);
            } else {
                drop.prepend(drag);
            }
        }
        this.drop_over(e);
    },

    global_drag_dropmiss: function(e) {
        // drag:dropmiss does not have e.drag and e.drop properties
        // we substitute them for the ease of use. For e.drop we use,
        // this.lastdroptarget (ghost node we use for indicating where to drop)
        e.drag = e.target;
        e.drop = this.lastdroptarget;
        // Check that drag object belongs to correct group
        if (!this.in_group(e.drag)) {
            return;
        }
        // Check that drop object belong to correct group
        if (!e.drop || !e.drop.inGroup(this.groups)) {
            return;
        }
        this.drag_dropmiss(e);
    },

    global_drop_hit: function(e) {
        // Check that drop object belong to correct group
        if (!e.drop || !e.drop.inGroup(this.groups)) {
            return;
        }
        this.drop_hit(e);
    },

    /**
     * This is used to build the text for the heading of the keyboard
     * drag drop menu and the text for the nodes in the list.
     * @method find_element_text
     * @param {Node} n The node to start searching for a valid text node.
     * @return {string} The text of the first text-like child node of n.
     */
    find_element_text: function(n) {
        var text = '';

        // Try to resolve using aria-label first.
        text = n.get('aria-label') || '';
        if (text.length > 0) {
            return text;
        }

        // Now try to resolve using aria-labelledby.
        var labelledByNode = n.get('aria-labelledby');
        if (labelledByNode) {
            var labelNode = Y.one('#' + labelledByNode);
            if (labelNode && labelNode.get('text').length > 0) {
                return labelNode.get('text');
            }
        }

        // The valid node types to get text from.
        var nodes = n.all('h2, h3, h4, h5, span:not(.actions):not(.menu-action-text), p, div.no-overflow, div.dimmed_text');

        nodes.each(function() {
            if (text === '') {
                if (Y.Lang.trim(this.get('text')) !== '') {
                    text = this.get('text');
                }
            }
        });

        if (text !== '') {
            return text;
        }
        return M.util.get_string('emptydragdropregion', 'moodle');
    },

    /**
     * This is used to initiate a keyboard version of a drag and drop.
     * A dialog will open listing all the valid drop targets that can be selected
     * using tab, tab, tab, enter.
     * @method global_start_keyboard_drag
     * @param {Event} e The keydown / click event on the grab handle.
     * @param {Node} dragcontainer The resolved draggable node (an ancestor of the drag handle).
     * @param {Node} draghandle The node that triggered this action.
     */
    global_start_keyboard_drag: function(e, draghandle, dragcontainer) {
        M.core.dragdrop.keydragcontainer = dragcontainer;
        M.core.dragdrop.keydraghandle = draghandle;

        // Get the name of the thing to move.
        var nodetitle = this.find_element_text(dragcontainer);
        var dialogtitle = M.util.get_string('movecontent', 'moodle', nodetitle);

        // Build the list of drop targets.
        var droplist = Y.Node.create('<ul></ul>');
        droplist.addClass('dragdrop-keyboard-drag');
        var listitem, listlink, listitemtext;

        // Search for possible drop targets.
        var droptargets = Y.all('.' + this.samenodeclass + ', .' + this.parentnodeclass);

        droptargets.each(function(node) {
            var validdrop = false;
            var labelroot = node;
            var className = node.getAttribute("class").split(' ').join(', .');

            if (node.drop && node.drop.inGroup(this.groups) && node.drop.get('node') !== dragcontainer &&
                    !(node.next(className) === dragcontainer && !this.detectkeyboarddirection)) {
                // This is a drag and drop target with the same class as the grabbed node.
                validdrop = true;
            } else {
                var elementgroups = node.getAttribute('data-draggroups').split(' ');
                var i, j;
                for (i = 0; i < elementgroups.length; i++) {
                    for (j = 0; j < this.groups.length; j++) {
                        if (elementgroups[i] === this.groups[j] && !node.ancestor('.yui3-dd-proxy') && !(node == dragcontainer ||
                            node.next(className) === dragcontainer || node.get('children').item(0) == dragcontainer)) {
                                // This is a parent node of the grabbed node (used for dropping in empty sections).
                                validdrop = true;
                                // This node will have no text - so we get the first valid text from the parent.
                                labelroot = node.get('parentNode');
                                break;
                        }
                    }
                    if (validdrop) {
                        break;
                    }
                }
            }

            if (validdrop) {
                // It is a valid drop target - create a list item for it.
                listitem = Y.Node.create('<li></li>');
                listlink = Y.Node.create('<a></a>');
                nodetitle = this.find_element_text(labelroot);

                if (this.samenodelabel && node.hasClass(this.samenodeclass)) {
                    listitemtext = M.util.get_string(this.samenodelabel.identifier, this.samenodelabel.component, nodetitle);
                } else if (this.parentnodelabel && node.hasClass(this.parentnodeclass)) {
                    listitemtext = M.util.get_string(this.parentnodelabel.identifier, this.parentnodelabel.component, nodetitle);
                } else {
                    listitemtext = M.util.get_string('tocontent', 'moodle', nodetitle);
                }
                listlink.setContent(listitemtext);

                // Add a data attribute so we can get the real drop target.
                listlink.setAttribute('data-drop-target', node.get('id'));
                // Allow tabbing to the link.
                listlink.setAttribute('tabindex', '0');
                listlink.setAttribute('role', 'button');

                // Set the event listeners for enter, space or click.
                listlink.on('click', this.global_keyboard_drop, this);
                listlink.on('key', this.global_keyboard_drop, 'down:enter,32', this);

                // Add to the list or drop targets.
                listitem.append(listlink);
                droplist.append(listitem);
            }
        }, this);

        // Create the dialog for the interaction.
        M.core.dragdrop.dropui = new M.core.dialogue({
            headerContent: dialogtitle,
            bodyContent: droplist,
            draggable: true,
            visible: true,
            center: true,
            modal: true
        });

        M.core.dragdrop.dropui.after('visibleChange', function(e) {
            // After the dialogue has been closed, we call the cancel function. This will
            // ensure that tidying up happens (e.g. focusing on the start Node).
            if (e.prevVal && !e.newVal) {
                this.global_cancel_keyboard_drag();
            }
        }, this);

        // Focus the first drop target.
        if (droplist.one('a')) {
            droplist.one('a').focus();
        }
    },

    /**
     * This is used as a simulated drag/drop event in order to prevent any
     * subtle bugs from creating a real instance of a drag drop event. This means
     * there are no state changes in the Y.DD.DDM and any undefined functions
     * will trigger an obvious and fatal error.
     * The end result is that we call all our drag/drop handlers but do not bubble the
     * event to anyone else.
     *
     * The functions/properties implemented in the wrapper are:
     * e.target
     * e.drag
     * e.drop
     * e.drag.get('node')
     * e.drop.get('node')
     * e.drag.addHandle()
     * e.drag.removeHandle()
     *
     * @method simulated_drag_drop_event
     * @param {Node} dragnode The drag container node
     * @param {Node} dropnode The node to initiate the drop on
     */
    simulated_drag_drop_event: function(dragnode, dropnode) {

        // Subclass for wrapping both drag and drop.
        var DragDropWrapper = function(node) {
            this.node = node;
        };

        // Method e.drag.get() - get the node.
        DragDropWrapper.prototype.get = function(param) {
            if (param === 'node' || param === 'dragNode' || param === 'dropNode') {
                return this.node;
            }
            if (param === 'activeHandle') {
                return this.node.one('.editing_move');
            }
            return null;
        };

        // Method e.drag.inGroup() - we have already run the group checks before triggering the event.
        DragDropWrapper.prototype.inGroup = function() {
            return true;
        };

        // Method e.drag.addHandle() - we don't want to run this.
        DragDropWrapper.prototype.addHandle = function() {};
        // Method e.drag.removeHandle() - we don't want to run this.
        DragDropWrapper.prototype.removeHandle = function() {};

        // Create instances of the DragDropWrapper.
        this.drop = new DragDropWrapper(dropnode);
        this.drag = new DragDropWrapper(dragnode);
        this.target = this.drop;
    },

    /**
     * This is used to complete a keyboard version of a drag and drop.
     * A drop event will be simulated based on the drag and drop nodes.
     * @method global_keyboard_drop
     * @param {Event} e The keydown / click event on the proxy drop node.
     */
    global_keyboard_drop: function(e) {
        // The drag node was saved.
        var dragcontainer = M.core.dragdrop.keydragcontainer;
        // The real drop node is stored in an attribute of the proxy.
        var droptarget = Y.one('#' + e.target.getAttribute('data-drop-target'));

        // Close the dialog.
        M.core.dragdrop.dropui.hide();
        // Cancel the event.
        e.preventDefault();
        // Detect the direction of travel.
        if (this.detectkeyboarddirection && dragcontainer.getY() > droptarget.getY()) {
            // We can detect the keyboard direction and it is going up.
            this.absgoingup = true;
            this.goingup = true;
        } else {
            // The default behaviour is to treat everything as moving down.
            this.absgoingup = false;
            this.goingup = false;
        }
        // Convert to drag drop events.
        var dragevent = new this.simulated_drag_drop_event(dragcontainer, dragcontainer);
        var dropevent = new this.simulated_drag_drop_event(dragcontainer, droptarget);
        // Simulate the full sequence.
        this.drag_start(dragevent);
        this.global_drop_over(dropevent);

        if (droptarget.hasClass(this.parentnodeclass) && droptarget.contains(dragcontainer)) {
            // Handle the case where an item is dropped into a container (for example an activity into a new section).
            droptarget.prepend(dragcontainer);
        }

        this.global_drop_hit(dropevent);
    },

    /**
     * This is used to cancel a keyboard version of a drag and drop.
     *
     * @method global_cancel_keyboard_drag
     */
    global_cancel_keyboard_drag: function() {
        if (M.core.dragdrop.keydragcontainer) {
            // Focus on the node which was being dragged.
            M.core.dragdrop.keydraghandle.focus();
            M.core.dragdrop.keydragcontainer = null;
        }
        if (M.core.dragdrop.dropui) {
            M.core.dragdrop.dropui.destroy();
        }
    },

    /**
     * Process key events on the drag handles.
     *
     * @method global_keydown
     * @param {EventFacade} e The keydown / click event on the drag handle.
     */
    global_keydown: function(e) {
        var draghandle = e.target.ancestor('.' + MOVEICON.cssclass, true),
            dragcontainer,
            draggroups;

        if (draghandle === null) {
            // The element clicked did not have a a draghandle in it's lineage.
            return;
        }

        if (e.keyCode === 27) {
            // Escape to cancel from anywhere.
            this.global_cancel_keyboard_drag();
            e.preventDefault();
            return;
        }

        // Only process events on a drag handle.
        if (!draghandle.hasClass(MOVEICON.cssclass)) {
            return;
        }

        // Do nothing if not space or enter.
        if (e.keyCode !== 13 && e.keyCode !== 32 && e.type !== 'click') {
            return;
        }

        // Check the drag groups to see if we are the handler for this node.
        draggroups = draghandle.getAttribute('data-draggroups').split(' ');
        var i, j;
        var validgroup = false;

        for (i = 0; i < draggroups.length; i++) {
            for (j = 0; j < this.groups.length; j++) {
                if (draggroups[i] === this.groups[j]) {
                    validgroup = true;
                    break;
                }
            }
            if (validgroup) {
                break;
            }
        }
        if (!validgroup) {
            return;
        }

        // Valid event - start the keyboard drag.
        dragcontainer = draghandle.ancestor('.yui3-dd-drop');
        this.global_start_keyboard_drag(e, draghandle, dragcontainer);

        e.preventDefault();
    },


    // Abstract functions definitions.

    /**
     * Callback to use when dragging starts.
     *
     * @method drag_start
     * @param {EventFacade} e
     */
    drag_start: function() {},

    /**
     * Callback to use for the drag:over event.
     *
     * @method dragOver
     * @param {EventFacade} e
     */
    dragOver: function() {},

    /**
     * Callback to use when dragging ends.
     *
     * @method drag_end
     * @param {EventFacade} e
     */
    drag_end: function() {},

    /**
     * Callback to use during dragging.
     *
     * @method drag_drag
     * @param {EventFacade} e
     */
    drag_drag: function() {},

    /**
     * Callback to use when dragging ends and is not over a drop target.
     *
     * @method drag_dropmiss
     * @param {EventFacade} e
     */
    drag_dropmiss: function() {},

    /**
     * Callback to use when a drop over event occurs.
     *
     * @method drop_over
     * @param {EventFacade} e
     */
    drop_over: function() {},

    /**
     * Callback to use on drop:hit.
     *
     * @method drop_hit
     * @param {EventFacade} e
     */
    drop_hit: function() {}
}, {
    NAME: 'dragdrop',
    ATTRS: {}
});

M.core = M.core || {};
M.core.dragdrop = DRAGDROP;


}, '@VERSION@', {"requires": ["base", "node", "io", "dom", "dd", "event-key", "event-focus", "moodle-core-notification"]});
YUI.add('moodle-core-blocks', function (Y, NAME) {

var MANAGER;
var BLOCKREGION;
var DRAGBLOCK;
/**
 * Provides drag and drop functionality for blocks.
 *
 * @module moodle-core-blockdraganddrop
 */

var AJAXURL = '/lib/ajax/blocks.php',
CSS = {
    BLOCK: 'block',
    BLOCKREGION: 'block-region',
    BLOCKADMINBLOCK: 'block_adminblock',
    EDITINGMOVE: 'editing_move',
    HEADER: 'header',
    LIGHTBOX: 'lightbox',
    REGIONCONTENT: 'region-content',
    SKIPBLOCK: 'skip-block',
    SKIPBLOCKTO: 'skip-block-to',
    MYINDEX: 'page-my-index',
    REGIONMAIN: 'region-main',
    BLOCKSMOVING: 'blocks-moving'
};

var SELECTOR = {
    DRAGHANDLE: '.' + CSS.HEADER + ' .commands .moodle-core-dragdrop-draghandle'
};

/**
 * Legacy drag and drop manager.
 * This drag and drop manager is specifically designed for themes using side-pre and side-post
 * that do not make use of the block output methods introduced by MDL-39824.
 *
 * @namespace M.core.blockdraganddrop
 * @class LegacyManager
 * @constructor
 * @extends M.core.dragdrop
 */
DRAGBLOCK = function() {
    DRAGBLOCK.superclass.constructor.apply(this, arguments);
};
Y.extend(DRAGBLOCK, M.core.dragdrop, {
    skipnodetop: null,
    skipnodebottom: null,
    dragsourceregion: null,
    initializer: function() {
        // Set group for parent class
        this.groups = ['block'];
        this.samenodeclass = CSS.BLOCK;
        this.parentnodeclass = CSS.REGIONCONTENT;

        // Add relevant classes and ID to 'content' block region on Dashboard page.
        var myhomecontent = Y.Node.all('body#' + CSS.MYINDEX + ' #' + CSS.REGIONMAIN + ' > .' + CSS.REGIONCONTENT);
        if (myhomecontent.size() > 0) {
            var contentregion = myhomecontent.item(0);
            contentregion.addClass(CSS.BLOCKREGION);
            contentregion.set('id', CSS.REGIONCONTENT);
            contentregion.one('div').addClass(CSS.REGIONCONTENT);
        }

        // Initialise blocks dragging
        // Find all block regions on the page
        var blockregionlist = Y.Node.all('div.' + CSS.BLOCKREGION);

        if (blockregionlist.size() === 0) {
            return false;
        }

        // See if we are missing either of block regions,
        // if yes we need to add an empty one to use as target
        if (blockregionlist.size() !== this.get('regions').length) {
            var blockregion = Y.Node.create('<div></div>')
                .addClass(CSS.BLOCKREGION);
            var regioncontent = Y.Node.create('<div></div>')
                .addClass(CSS.REGIONCONTENT);
            blockregion.appendChild(regioncontent);
            var pre = blockregionlist.filter('#region-pre');
            var post = blockregionlist.filter('#region-post');

            if (pre.size() === 0 && post.size() === 1) {
                // pre block is missing, instert it before post
                blockregion.setAttrs({id: 'region-pre'});
                post.item(0).insert(blockregion, 'before');
                blockregionlist.unshift(blockregion);
            } else if (post.size() === 0 && pre.size() === 1) {
                // post block is missing, instert it after pre
                blockregion.setAttrs({id: 'region-post'});
                pre.item(0).insert(blockregion, 'after');
                blockregionlist.push(blockregion);
            }
        }

        blockregionlist.each(function(blockregionnode) {

            // Setting blockregion as droptarget (the case when it is empty)
            // The region-post (the right one)
            // is very narrow, so add extra padding on the left to drop block on it.
            new Y.DD.Drop({
                node: blockregionnode.one('div.' + CSS.REGIONCONTENT),
                groups: this.groups,
                padding: '40 240 40 240'
            });

            // Make each div element in the list of blocks draggable
            var del = new Y.DD.Delegate({
                container: blockregionnode,
                nodes: '.' + CSS.BLOCK,
                target: true,
                handles: [SELECTOR.DRAGHANDLE],
                invalid: '.block-hider-hide, .block-hider-show, .moveto',
                dragConfig: {groups: this.groups}
            });
            del.dd.plug(Y.Plugin.DDProxy, {
                // Don't move the node at the end of the drag
                moveOnEnd: false
            });
            del.dd.plug(Y.Plugin.DDWinScroll);

            var blocklist = blockregionnode.all('.' + CSS.BLOCK);
            blocklist.each(function(blocknode) {
                var move = blocknode.one('a.' + CSS.EDITINGMOVE);
                if (move) {
                    move.replace(this.get_drag_handle(move.getAttribute('title'), '', 'iconsmall', true));
                    blocknode.one(SELECTOR.DRAGHANDLE).setStyle('cursor', 'move');
                }
            }, this);
        }, this);
    },

    get_block_id: function(node) {
        return Number(node.get('id').replace(/inst/i, ''));
    },

    get_block_region: function(node) {
        var region = node.ancestor('div.' + CSS.BLOCKREGION).get('id').replace(/region-/i, '');
        if (Y.Array.indexOf(this.get('regions'), region) === -1) {
            // Must be standard side-X
            if (window.right_to_left()) {
                if (region === 'post') {
                    region = 'pre';
                } else if (region === 'pre') {
                    region = 'post';
                }
            }
            return 'side-' + region;
        }
        // Perhaps custom region
        return region;
    },

    get_region_id: function(node) {
        return node.get('id').replace(/region-/i, '');
    },

    drag_start: function(e) {
        // Get our drag object
        var drag = e.target;

        // Store the parent node of original drag node (block)
        // we will need it later for show/hide empty regions
        this.dragsourceregion = drag.get('node').ancestor('div.' + CSS.BLOCKREGION);

        // Determine skipnodes and store them
        if (drag.get('node').previous() && drag.get('node').previous().hasClass(CSS.SKIPBLOCK)) {
            this.skipnodetop = drag.get('node').previous();
        }
        if (drag.get('node').next() && drag.get('node').next().hasClass(CSS.SKIPBLOCKTO)) {
            this.skipnodebottom = drag.get('node').next();
        }

        // Add the blocks-moving class so that the theme can respond if need be.
        Y.one('body').addClass(CSS.BLOCKSMOVING);
    },

    drop_over: function(e) {
        // Get a reference to our drag and drop nodes
        var drag = e.drag.get('node');
        var drop = e.drop.get('node');

        // We need to fix the case when parent drop over event has determined
        // 'goingup' and appended the drag node after admin-block.
        if (drop.hasClass(this.parentnodeclass) &&
                drop.one('.' + CSS.BLOCKADMINBLOCK) &&
                drop.one('.' + CSS.BLOCKADMINBLOCK).next('.' + CSS.BLOCK)) {
            drop.prepend(drag);
        }

        // Block is moved within the same region
        // stop here, no need to modify anything.
        if (this.dragsourceregion.contains(drop)) {
            return false;
        }

        // TODO: Hiding-displaying block region only works for base theme blocks
        // (region-pre, region-post) at the moment. It should be improved
        // to work with custom block regions as well.

        // TODO: Fix this for the case when user drag block towards empty section,
        // then the section appears, then user chnages his mind and moving back to
        // original section. The opposite section remains opened and empty.

        var documentbody = Y.one('body');
        // Moving block towards hidden region-content, display it
        var regionname = this.get_region_id(this.dragsourceregion);
        if (documentbody.hasClass('side-' + regionname + '-only')) {
            documentbody.removeClass('side-' + regionname + '-only');
        }

        // Moving from empty region-content towards the opposite one,
        // hide empty one (only for region-pre, region-post areas at the moment).
        regionname = this.get_region_id(drop.ancestor('div.' + CSS.BLOCKREGION));
        if (this.dragsourceregion.all('.' + CSS.BLOCK).size() === 0 &&
                this.dragsourceregion.get('id').match(/(region-pre|region-post)/i)) {
            if (!documentbody.hasClass('side-' + regionname + '-only')) {
                documentbody.addClass('side-' + regionname + '-only');
            }
        }
    },

    drag_end: function() {
        // clear variables
        this.skipnodetop = null;
        this.skipnodebottom = null;
        this.dragsourceregion = null;
        // Remove the blocks moving class once the drag-drop is over.
        Y.one('body').removeClass(CSS.BLOCKSMOVING);
    },

    drag_dropmiss: function(e) {
        // Missed the target, but we assume the user intended to drop it
        // on the last last ghost node location, e.drag and e.drop should be
        // prepared by global_drag_dropmiss parent so simulate drop_hit(e).
        this.drop_hit(e);
    },

    drop_hit: function(e) {
        var drag = e.drag;
        // Get a reference to our drag node
        var dragnode = drag.get('node');
        var dropnode = e.drop.get('node');

        // Amend existing skipnodes
        if (dragnode.previous() && dragnode.previous().hasClass(CSS.SKIPBLOCK)) {
            // the one that belongs to block below move below
            dragnode.insert(dragnode.previous(), 'after');
        }
        // Move original skipnodes
        if (this.skipnodetop) {
            dragnode.insert(this.skipnodetop, 'before');
        }
        if (this.skipnodebottom) {
            dragnode.insert(this.skipnodebottom, 'after');
        }

        // Add lightbox if it not there
        var lightbox = M.util.add_lightbox(Y, dragnode);

        // Prepare request parameters
        var params = {
            sesskey: M.cfg.sesskey,
            pagehash: this.get('pagehash'),
            action: 'move',
            bui_moveid: this.get_block_id(dragnode),
            bui_newregion: this.get_block_region(dropnode)
        };

        if (this.get('cmid')) {
            params.cmid = this.get('cmid');
        }

        if (dragnode.next('.' + this.samenodeclass) && !dragnode.next('.' + this.samenodeclass).hasClass(CSS.BLOCKADMINBLOCK)) {
            params.bui_beforeid = this.get_block_id(dragnode.next('.' + this.samenodeclass));
        }

        // Do AJAX request
        Y.io(M.cfg.wwwroot + AJAXURL, {
            method: 'POST',
            data: params,
            on: {
                start: function() {
                    lightbox.show();
                },
                success: function(tid, response) {
                    window.setTimeout(function() {
                        lightbox.hide();
                    }, 250);
                    try {
                        var responsetext = Y.JSON.parse(response.responseText);
                        if (responsetext.error) {
                            new M.core.ajaxException(responsetext);
                        }
                    } catch (e) {
                        // Ignore.
                    }
                },
                failure: function(tid, response) {
                    this.ajax_failure(response);
                    lightbox.hide();
                }
            },
            context: this
        });
    }
}, {
    NAME: 'core-blocks-dragdrop',
    ATTRS: {
        pagehash: {
            value: null
        },
        regions: {
            value: null
        }
    }
});

M.core = M.core || {};
M.core.blockdraganddrop = M.core.blockdraganddrop || {};

/**
 * True if the page is using the new blocks methods.
 * @private
 * @static
 * @property M.core.blockdraganddrop._isusingnewblocksmethod
 * @type Boolean
 * @default null
 */
M.core.blockdraganddrop._isusingnewblocksmethod = null;

/**
 * Returns true if the page is using the new blocks methods.
 * @static
 * @method M.core.blockdraganddrop.is_using_blocks_render_method
 * @return Boolean
 */
M.core.blockdraganddrop.is_using_blocks_render_method = function() {
    if (this._isusingnewblocksmethod === null) {
        var goodregions = Y.all('.block-region[data-blockregion]').size();
        var allregions = Y.all('.block-region').size();
        this._isusingnewblocksmethod = (allregions === goodregions);
        if (goodregions > 0 && allregions > 0 && goodregions !== allregions) {
            Y.log('Both core_renderer::blocks and core_renderer::blocks_for_region have been used.', 'warn', 'moodle-core_blocks');
        }
    }
    return this._isusingnewblocksmethod;
};

/**
 * Initialises a drag and drop manager.
 * This should only ever be called once for a page.
 * @static
 * @method M.core.blockdraganddrop.init
 * @param {Object} params
 * @return Manager
 */
M.core.blockdraganddrop.init = function(params) {
    if (this.is_using_blocks_render_method()) {
        Y.log('Block drag and drop initialised for the blocks method.', 'info', 'moodle-core_blocks');
        new MANAGER(params);
    } else {
        Y.log('Block drag and drop initialised with the legacy manager (blocks_for_region used).', 'info', 'moodle-core_blocks');
        new DRAGBLOCK(params);
    }
};

/*
 * Legacy code to keep things working.
 */
M.core_blocks = M.core_blocks || {};
M.core_blocks.init_dragdrop = function(params) {
    M.core.blockdraganddrop.init(params);
};
/**
 * This file contains the drag and drop manager class.
 *
 * Provides drag and drop functionality for blocks.
 *
 * @module moodle-core-blockdraganddrop
 */

/**
 * Constructs a new Block drag and drop manager.
 *
 * @namespace M.core.blockdraganddrop
 * @class Manager
 * @constructor
 * @extends M.core.dragdrop
 */
MANAGER = function() {
    MANAGER.superclass.constructor.apply(this, arguments);
};
MANAGER.prototype = {

    /**
     * The skip block link from above the block being dragged while a drag is in progress.
     * Required by the M.core.dragdrop from whom this class extends.
     * @private
     * @property skipnodetop
     * @type Node
     * @default null
     */
    skipnodetop: null,

    /**
     * The skip block link from below the block being dragged while a drag is in progress.
     * Required by the M.core.dragdrop from whom this class extends.
     * @private
     * @property skipnodebottom
     * @type Node
     * @default null
     */
    skipnodebottom: null,

    /**
     * An associative object of regions and the
     * @property regionobjects
     * @type {Object} Primitive object mocking an associative array.
     * @type {BLOCKREGION} [regionname]* Each item uses the region name as the key with the value being
     *      an instance of the BLOCKREGION class.
     */
    regionobjects: {},

    /**
     * Called during the initialisation process of the object.
     * @method initializer
     */
    initializer: function() {
        Y.log('Initialising drag and drop for blocks.', 'info');
        var regionnames = this.get('regions');
        var i = 0;
        var dragContainer;
        var dragdelegation;
        var region;
        var regionContainer;
        var regionname;

        // Evil required by M.core.dragdrop.
        this.groups = ['block'];
        this.samenodeclass = CSS.BLOCK;
        this.parentnodeclass = CSS.BLOCKREGION;
        // Detect the direction of travel.
        this.detectkeyboarddirection = true;

        // Add relevant classes and ID to 'content' block region on Dashboard page.
        var myhomecontent = Y.Node.all('body#' + CSS.MYINDEX + ' #' + CSS.REGIONMAIN + ' > .' + CSS.REGIONCONTENT);
        if (myhomecontent.size() > 0) {
            var contentregion = myhomecontent.item(0);
            contentregion.addClass(CSS.BLOCKREGION);
            contentregion.set('id', CSS.REGIONCONTENT);
            contentregion.one('div').addClass(CSS.REGIONCONTENT);
        }

        for (i in regionnames) {
            regionname = regionnames[i];
            regionContainer = Y.one('#block-region-' + regionname);
            region = new BLOCKREGION({
                manager: this,
                region: regionname,
                node: regionContainer,
            });
            this.regionobjects[regionname] = region;

            // Setting blockregion as droptarget (the case when it is empty)
            // The region-post (the right one)
            // is very narrow, so add extra padding on the left to drop block on it.
            new Y.DD.Drop({
                node: region.get_droptarget(),
                groups: this.groups,
                padding: '40 240 40 240'
            });

            // Make each div element in the list of blocks draggable
            dragdelegation = new Y.DD.Delegate({
                container: region.get_droptarget(),
                nodes: '.' + CSS.BLOCK,
                target: true,
                handles: [SELECTOR.DRAGHANDLE],
                invalid: '.block-hider-hide, .block-hider-show, .moveto, .block_fake',
                dragConfig: {groups: this.groups}
            });

            dragdelegation.dd.plug(Y.Plugin.DDProxy, {
                // Don't move the node at the end of the drag
                moveOnEnd: false
            });

            if (regionContainer === null) {
                dragdelegation.dd.plug(Y.Plugin.DDWinScroll);
            } else {
                dragContainer = regionContainer.ancestor('.drag-container', true);
                if (dragContainer) {
                    dragdelegation.dd.plug(Y.Plugin.DDNodeScroll, {
                        node: dragContainer,
                    });
                } else {
                    dragdelegation.dd.plug(Y.Plugin.DDWinScroll);
                }
            }

            // On the DD Manager start operation, we enable all block regions so that they can be drop targets. This
            // must be done *before* drag:start but after dragging has been initialised.
            Y.DD.DDM.on('ddm:start', this.enable_all_regions, this);

            region.change_block_move_icons(this);
        }
        Y.log('Initialisation of drag and drop for blocks complete.', 'info');
    },

    /**
     * Returns the ID of the block the given node represents.
     * @method get_block_id
     * @param {Node} node
     * @return {int} The blocks ID in the database.
     */
    get_block_id: function(node) {
        return Number(node.get('id').replace(/inst/i, ''));
    },

    /**
     * Returns the block region that the node is part of or belonging to.
     * @method get_block_region
     * @param {Y.Node} node
     * @return {string} The region name.
     */
    get_block_region: function(node) {
        if (!node.test('[data-blockregion]')) {
            node = node.ancestor('[data-blockregion]');
        }
        return node.getData('blockregion');
    },

    /**
     * Returns the BLOCKREGION instance that represents the block region the given node is part of.
     * @method get_region_object
     * @param {Y.Node} node
     * @return {BLOCKREGION}
     */
    get_region_object: function(node) {
        return this.regionobjects[this.get_block_region(node)];
    },

    /**
     * Enables all fo the regions so that they are all visible while dragging is occuring.
     *
     * @method enable_all_regions
     */
    enable_all_regions: function() {
        var groups = Y.DD.DDM.activeDrag.get('groups');

        // As we're called by Y.DD.DDM, we can't be certain that the call
        // relates specifically to a block drag/drop operation. Test
        // whether the relevant group applies here.
        if (!groups || Y.Array.indexOf(groups, 'block') === -1) {
            return;
        }

        var i;
        for (i in this.regionobjects) {
            if (!this.regionobjects.hasOwnProperty(i)) {
                continue;
            }
            this.regionobjects[i].enable();
        }
    },

    /**
     * Disables enabled regions if they contain no blocks.
     * @method disable_regions_if_required
     */
    disable_regions_if_required: function() {
        var i = 0;
        for (i in this.regionobjects) {
            this.regionobjects[i].disable_if_required();
        }
    },

    /**
     * Called by M.core.dragdrop.global_drag_start when dragging starts.
     * @method drag_start
     * @param {Event} e
     */
    drag_start: function(e) {
        // Get our drag object
        var drag = e.target;

        // Store the parent node of original drag node (block)
        // we will need it later for show/hide empty regions

        // Determine skipnodes and store them
        if (drag.get('node').previous() && drag.get('node').previous().hasClass(CSS.SKIPBLOCK)) {
            this.skipnodetop = drag.get('node').previous();
        }
        if (drag.get('node').next() && drag.get('node').next().hasClass(CSS.SKIPBLOCKTO)) {
            this.skipnodebottom = drag.get('node').next();
        }
    },

    dragOver: function(e) {
        var nearestRegion = e.drop.get('node').ancestor('.drag-container', true);
        if (nearestRegion) {
            if (e.drag[Y.Plugin.DDNodeScroll]) {
                if (e.drag[Y.Plugin.DDNodeScroll].get('node') === nearestRegion) {
                    // Do not bother resetting the region - it has not changed.
                    return;
                } else {
                    e.drag.unplug(Y.Plugin.DDNodeScroll);
                }
            }
            e.drag.plug(Y.Plugin.DDNodeScroll, {
                node: nearestRegion,
            });
        }
    },

    /**
     * Called by M.core.dragdrop.global_drop_over when something is dragged over a drop target.
     * @method drop_over
     * @param {Event} e
     */
    drop_over: function(e) {
        // Get a reference to our drag and drop nodes
        var drag = e.drag.get('node');
        var drop = e.drop.get('node');

        // We need to fix the case when parent drop over event has determined
        // 'goingup' and appended the drag node after admin-block.
        if (drop.hasClass(CSS.REGIONCONTENT) &&
                drop.one('.' + CSS.BLOCKADMINBLOCK) &&
                drop.one('.' + CSS.BLOCKADMINBLOCK).next('.' + CSS.BLOCK)) {
            drop.prepend(drag);
        }
    },

    /**
     * Called by M.core.dragdrop.global_drop_end when a drop has been completed.
     * @method drop_end
     */
    drop_end: function() {
        // Clear variables.
        this.skipnodetop = null;
        this.skipnodebottom = null;
        this.disable_regions_if_required();
    },

    /**
     * Called by M.core.dragdrop.global_drag_dropmiss when something has been dropped on a node that isn't contained by
     * a drop target.
     *
     * @method drag_dropmiss
     * @param {Event} e
     */
    drag_dropmiss: function(e) {
        // Missed the target, but we assume the user intended to drop it
        // on the last ghost node location, e.drag and e.drop should be
        // prepared by global_drag_dropmiss parent so simulate drop_hit(e).
        this.drop_hit(e);
    },

    /**
     * Called by M.core.dragdrop.global_drag_hit when something has been dropped on a drop target.
     * @method drop_hit
     * @param {Event} e
     */
    drop_hit: function(e) {
        // Get a reference to our drag node
        var dragnode = e.drag.get('node');
        var dropnode = e.drop.get('node');

        // Amend existing skipnodes
        if (dragnode.previous() && dragnode.previous().hasClass(CSS.SKIPBLOCK)) {
            // the one that belongs to block below move below
            dragnode.insert(dragnode.previous(), 'after');
        }
        // Move original skipnodes
        if (this.skipnodetop) {
            dragnode.insert(this.skipnodetop, 'before');
        }
        if (this.skipnodebottom) {
            dragnode.insert(this.skipnodebottom, 'after');
        }

        // Add lightbox if it not there
        var lightbox = M.util.add_lightbox(Y, dragnode);

        // Prepare request parameters
        var params = {
            sesskey: M.cfg.sesskey,
            pagehash: this.get('pagehash'),
            action: 'move',
            bui_moveid: this.get_block_id(dragnode),
            bui_newregion: this.get_block_region(dropnode)
        };

        if (this.get('cmid')) {
            params.cmid = this.get('cmid');
        }

        if (dragnode.next('.' + CSS.BLOCK) && !dragnode.next('.' + CSS.BLOCK).hasClass(CSS.BLOCKADMINBLOCK)) {
            params.bui_beforeid = this.get_block_id(dragnode.next('.' + CSS.BLOCK));
        }

        // Do AJAX request
        Y.io(M.cfg.wwwroot + AJAXURL, {
            method: 'POST',
            data: params,
            on: {
                start: function() {
                    lightbox.show();
                },
                success: function(tid, response) {
                    window.setTimeout(function() {
                        lightbox.hide();
                    }, 250);
                    try {
                        var responsetext = Y.JSON.parse(response.responseText);
                        if (responsetext.error) {
                            new M.core.ajaxException(responsetext);
                        }
                    } catch (e) {
                        // Ignore.
                    }
                },
                failure: function(tid, response) {
                    this.ajax_failure(response);
                    lightbox.hide();
                },
                complete: function() {
                    this.disable_regions_if_required();
                }
            },
            context: this
        });
    }
};
Y.extend(MANAGER, M.core.dragdrop, MANAGER.prototype, {
    NAME: 'core-blocks-dragdrop-manager',
    ATTRS: {
        /**
         * The page identifier.
         * @attribute pagehash
         * @type string|null
         * @default null
         */
        pagehash: {
            value: null
        },

        /**
         * An array of block regions that are present on the page.
         * @attribute regions
         * @type array|null
         * @default Array[]
         */
        regions: {
            value: []
        }
    }
});
/**
 * This file contains the Block Region class used by the drag and drop manager.
 *
 * Provides drag and drop functionality for blocks.
 *
 * @module moodle-core-blockdraganddrop
 */

/**
 * Constructs a new block region object.
 *
 * @namespace M.core.blockdraganddrop
 * @class BlockRegion
 * @constructor
 * @extends Base
 */
BLOCKREGION = function() {
    BLOCKREGION.superclass.constructor.apply(this, arguments);
};
BLOCKREGION.prototype = {
    /**
     * Called during the initialisation process of the object.
     * @method initializer
     */
    initializer: function() {
        var node = this.get('node');
        Y.log('Block region `' + this.get('region') + '` initialising', 'info');
        if (!node) {
            Y.log('block region known about but no HTML structure found for it. Guessing structure.', 'warn');
            node = this.create_and_add_node();
        }
        var body = Y.one('body'),
            hasblocks = node.all('.' + CSS.BLOCK).size() > 0,
            hasregionclass = this.get_has_region_class();
        this.set('hasblocks', hasblocks);
        if (!body.hasClass(hasregionclass)) {
            body.addClass(hasregionclass);
        }
        body.addClass((hasblocks) ? this.get_used_region_class() : this.get_empty_region_class());
        body.removeClass((hasblocks) ? this.get_empty_region_class() : this.get_used_region_class());
    },
    /**
     * Creates a generic block region node and adds it to the DOM at the best guess location.
     * Any calling of this method is an unfortunate circumstance.
     * @method create_and_add_node
     * @return Node The newly created Node
     */
    create_and_add_node: function() {
        var c = Y.Node.create,
            region = this.get('region'),
            node = c('<div id="block-region-' + region + '" data-droptarget="1"></div>')
                .addClass(CSS.BLOCKREGION)
                .setData('blockregion', region),
            regions = this.get('manager').get('regions'),
            i,
            haspre = false,
            haspost = false,
            added = false,
            pre,
            post;

        for (i in regions) {
            if (regions[i].match(/(pre|left)/)) {
                haspre = regions[i];
            } else if (regions[i].match(/(post|right)/)) {
                haspost = regions[i];
            }
        }

        if (haspre !== false && haspost !== false) {
            if (region === haspre) {
                post = Y.one('#block-region-' + haspost);
                if (post) {
                    post.insert(node, 'before');
                    added = true;
                }
            } else {
                pre = Y.one('#block-region-' + haspre);
                if (pre) {
                    pre.insert(node, 'after');
                    added = true;
                }
            }
        }
        if (added === false) {
            Y.one('body').append(node);
        }
        this.set('node', node);

        return node;
    },

    /**
     * Change the move icons to enhanced drag handles and changes the cursor to a move icon when over the header.
     * @param M.core.dragdrop the block manager
     * @method change_block_move_icons
     */
    change_block_move_icons: function(manager) {
        var handle;
        this.get('node').all('.' + CSS.BLOCK + ' a.' + CSS.EDITINGMOVE).each(function(moveicon) {
            moveicon.setStyle('cursor', 'move');
            handle = manager.get_drag_handle(moveicon.getAttribute('title'), '', 'icon', true);
            // Dragdrop module assigns this with a button role by default.
            // However, the block move icon is part of a menubar, so it should have a menuitem role.
            handle.setAttribute('role', 'menuitem');
            moveicon.replace(handle);
        });
    },

    /**
     * Returns the class name on the body that signifies the document knows about this region.
     * @method get_has_region_class
     * @return String
     */
    get_has_region_class: function() {
        return 'has-region-' + this.get('region');
    },

    /**
     * Returns the class name to use on the body if the region contains no blocks.
     * @method get_empty_region_class
     * @return String
     */
    get_empty_region_class: function() {
        return 'empty-region-' + this.get('region');
    },

    /**
     * Returns the class name to use on the body if the region contains blocks.
     * @method get_used_region_class
     * @return String
     */
    get_used_region_class: function() {
        return 'used-region-' + this.get('region');
    },

    /**
     * Returns the node to use as the drop target for this region.
     * @method get_droptarget
     * @return Node
     */
    get_droptarget: function() {
        var node = this.get('node');
        if (node.test('[data-droptarget="1"]')) {
            return node;
        }
        return node.one('[data-droptarget="1"]');
    },

    /**
     * Enables the block region so that we can be sure the user can see it.
     * This is done even if it is empty.
     * @method enable
     */
    enable: function() {
        Y.one('body').addClass(this.get_used_region_class()).removeClass(this.get_empty_region_class());
    },

    /**
     * Disables the region if it contains no blocks, essentially hiding it from the user.
     * @method disable_if_required
     */
    disable_if_required: function() {
        if (this.get('node').all('.' + CSS.BLOCK).size() === 0) {
            Y.one('body').addClass(this.get_empty_region_class()).removeClass(this.get_used_region_class());
        }
    }
};
Y.extend(BLOCKREGION, Y.Base, BLOCKREGION.prototype, {
    NAME: 'core-blocks-dragdrop-blockregion',
    ATTRS: {

        /**
         * The drag and drop manager that created this block region instance.
         * @attribute manager
         * @type M.core.blockdraganddrop.Manager
         * @writeOnce
         */
        manager: {
            // Can only be set during initialisation and must be set then.
            writeOnce: 'initOnly',
            validator: function(value) {
                return Y.Lang.isObject(value) && value instanceof MANAGER;
            }
        },

        /**
         * The name of the block region this object represents.
         * @attribute region
         * @type String
         * @writeOnce
         */
        region: {
            // Can only be set during initialisation and must be set then.
            writeOnce: 'initOnly',
            validator: function(value) {
                return Y.Lang.isString(value);
            }
        },

        /**
         * The node the block region HTML starts at.s
         * @attribute region
         * @type Y.Node
         */
        node: {
            validator: function(value) {
                return Y.Lang.isObject(value) || Y.Lang.isNull(value);
            }
        },

        /**
         * True if the block region currently contains blocks.
         * @attribute hasblocks
         * @type Boolean
         * @default false
         */
        hasblocks: {
            value: false,
            validator: function(value) {
                return Y.Lang.isBoolean(value);
            }
        }
    }
});


}, '@VERSION@', {
    "requires": [
        "base",
        "node",
        "io",
        "dom",
        "dd",
        "dd-scroll",
        "moodle-core-dragdrop",
        "moodle-core-notification"
    ]
});
